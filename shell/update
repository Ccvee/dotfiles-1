# .dotfiles/shell/update
#
# Update dotfiles and provide instructions for updating the system
# THIS FILE IS SOURCED
#

# ==============================================================================
# initialize script and dependencies
# ==============================================================================

# get bootstrap folder
readonly bootstrap_path="${DOTFILES}/bootstrap"
source "${bootstrap_path}/helpers.sh"

# ==============================================================================
# Command functions
# ==============================================================================

# ------------------------------------------------------------------------------
# Meta
# ------------------------------------------------------------------------------

__dotfiles_usage() {
  dkousage  "update <command>"
  echo "
  Utility Commands
    dotfiles    -- update dotfiles (git pull)
    reload      -- reload this script if it was modified
    secret      -- update ~/.secret (git pull)

  Shell Tools
    fzf         -- update fzf with flags to not update rc scripts
    node        -- install latest node via nvm
    nvm         -- update nvm installation

  Packages
    gem         -- update rubygems and global gems for current ruby
    go          -- golang
    heroku      -- heroku toolbelt
    pip         -- update all versions of pip (OS dependent)

  Arch Linux
    arch        -- update arch packages

  OSX
    brew        -- osx homebrew packages
    osx         -- repair osx permissions and check software updates
"
}

__dotfiles_reload() {
  source "${DOTFILES}/shell/update" && dkostatus "Reloaded shell/update"
}

__dotfiles_update_dotfiles() {
  dkostatus "Updating dotfiles"
  cd "$DOTFILES" || { dkoerr "No \$DOTFILES directory" && return 1; }
  git pull --rebase || { dkoerr "Error updating dotfiles" && return 1; }
  dkostatus "Updating dotfiles submodules"
  git submodule update --init || {
    dkoerr "Error updating dotfiles submodules" && return 1
  }
  __dotfiles_reload
  [ -n "$ZSH_VERSION" ] && dkostatus "Done, don't forget to zplug update"
  cd - || return 1
}

__dotfiles_update_secret() {
  dkostatus "Updating secret"
  cd "${HOME}/.secret" || { dkoerr "No ~/.secret directory" && return 1; }
  git pull --rebase --recurse-submodules && \
  git submodule update --init
  cd - || return 1
}

# ------------------------------------------------------------------------------
# Externals
# ------------------------------------------------------------------------------

__dotfiles_update_fzf() {
  dkostatus "Updating fzf"
  cd "${HOME}/.fzf" || { dkoerr "Could not cd to ~/.fzf" && return 1; }
  git pull || { dkoerr "Could not update ~/.fzf" && return 1; }
  ./install --key-bindings --completion --no-update-rc
  local return_status=$?
  cd - || return 1
  return $return_status
}

__dotfiles_update_gems() {
  has_program "gem" || { dkoerr "rubygems is not installed" && return 1; }
  dkostatus "Updating RubyGems itself"
  gem update --system  || { dkoerr "Could not update system gems" && return 1; }
  dkostatus "Updating gems"
  gem update
  rehash
}

__dotfiles_update_go() {
  has_program "go" || { dkoerr "go is not installed" && return 1; }
  dkostatus "Updating go packages"
  go get -u all
  rehash
}

__dotfiles_update_heroku() {
  has_program "heroku" || { dkoerr "heroku is not installed" && return 1; }
  dkostatus "Updating heroku"
  heroku update
}

__dotfiles_update_node() {
  local desired_node="v4"
  local desired_node_minor
  local previous_node

  source "${NVM_DIR}/nvm.sh"
  desired_node_minor="$(nvm version-remote "$desired_node")"
  previous_node="$(nvm current)"

  dkostatus "Previous node version was $previous_node"
  if [ "$desired_node_minor" != "$previous_node" ]; then
    dkostatus "Installing and using new node $desired_node_minor"
    nvm install             "$desired_node"
    nvm use                 "$desired_node"
    nvm alias default       "$desired_node"
    npm install --global npm@latest
    nvm reinstall-packages  "$previous_node"
    rehash
  else
    dkostatus_ "Node version is already up-to-date."
  fi
}

__dotfiles_update_nvm() {
  local previous_nvm
  local latest_nvm

  if [ ! -d "$NVM_DIR" ]; then
    dkostatus "Installing nvm"
    git clone https://github.com/creationix/nvm.git "$NVM_DIR"
  fi

  dkostatus "Updating nvm"
  cd "$NVM_DIR"  || { dkoerr "Could not cd to \$NVM_DIR" && return 1; }

  previous_nvm="$(git describe --abbrev=0 --tags)"
  { git checkout master && git pull; } || {
    dkoerr "Could not update nvm"
    cd - || return 1
    return 1;
  }
  latest_nvm="$(git describe --abbrev=0 --tags)"
  git checkout "$latest_nvm" || {
    dkoerr "Could not update nvm"
    cd - || return 1
    return 1
  }
  [ "$previous_nvm" != "$latest_nvm" ] && source "$NVM_DIR/nvm.sh"
  cd - || return 1
}

__dotfiles_update_pip() {
  local pip_command=${1:-pip}
  dkostatus "Updating $pip_command"
  if has_program "$pip_command"; then
    $pip_command install --upgrade setuptools || return 1
    $pip_command install --upgrade pip        || return 1
  fi
}

# ------------------------------------------------------------------------------
# OS-specific commands
# ------------------------------------------------------------------------------

__dotfiles_update_linux() {
  case "$1" in
    arch) __dotfiles_update_arch      ;;
    pip)  __dotfiles_update_pip "pip" ;;
  esac
}

__dotfiles_update_darwin() {
  case "$1" in
    brew) __dotfiles_update_brew  ;;
    osx)  __dotfiles_update_osx   ;;
    pip)
      __dotfiles_update_pip "pip"
      __dotfiles_update_pip "pip2"
      __dotfiles_update_pip "pip3"
      ;;
  esac
}

# ------------------------------------------------------------------------------
# OS: Arch Linux
# ------------------------------------------------------------------------------

__dotfiles_update_arch() {
  dkostatus "Arch Linux system update"
  if has_program "pacaur"; then
    # update system
    pacaur -Syu
  elif has_program "yaourt"; then
    # -Sy         -- get new file list
    yaourt --sync --refresh
    yaourt -Syua
  elif has_program "aura"; then
    aura -Syua
  else
    pacman -Syu
  fi
}

# ------------------------------------------------------------------------------
# OS: OSX
# ------------------------------------------------------------------------------

__dotfiles_update_osx() {
  # fix file system permissions
  dkostatus "Repairing permissions"
  diskutil repairPermissions / || dkoerr "Error repairing permissions"

  dkostatus "OSX system update"
  sudo softwareupdate -i -a || { dkoerr "Error updating software permissions" && return 1; }
}

__dotfiles_update_brew() {
  local is_python_rebuild=""
  local outdated=""

  dkostatus "Updating homebrew"
  cd "$DOTFILES" || { dkoerr "Can't enter \$DOTFILES to run brew in clean environment" && return 1; }
  brew update

  outdated="$(brew outdated --quiet)"

  if [ -z "$outdated" ]; then
    dkostatus "All packages up-to-date"
  else
    dkostatus "Upgrade packages"
    brew upgrade --all --cleanup

    # @TODO this isn't working
    is_python_rebuild="$(echo "$outdated" | grep "python3")"
  fi

  # handle python3 and macvim
  if [ -n "$is_python_rebuild" ]; then
    __dotfiles_update_python3 && __dotfiles_update_macvim
  fi

  dkostatus "Cleanup old versions and prune dead symlinks"
  brew cleanup
  brew cask cleanup
  brew prune
  rehash
}

__dotfiles_update_python3() {
  dkostatus_ "Linking python3 apps"
  brew linkapps python3 || { dkoerr "Error linking python3" && return 1; }
  dkostatus "Python3 was upgraded"
  dkostatus_ "Updating pip and setuptools"
  pip3 install --upgrade pip setuptools || { dkoerr "Error updating setuptools" && return 1; }
}

__dotfiles_update_macvim() {
  dkostatus_ "Rebuilding macvim for new python3"
  brew reinstall macvim \
    --with-custom-icons --with-override-system-vim \
    --with-lua          --with-python3 \
    || { dkoerr "Error reinstalling macvim" && return 1; }
  dkostatus_ "Linking new macvim.app"
  brew linkapps macvim
}

# ==============================================================================
# Main
# ==============================================================================

__dotfiles_main() {
  if [[ $# -eq 0 ]]; then
    __dotfiles_usage
    return 1
  fi

  case $1 in
    reload)   __dotfiles_reload           ;;
    dotfiles) __dotfiles_update_dotfiles  ;;
    secret)   __dotfiles_update_secret    ;;
    fzf)      __dotfiles_update_fzf       ;;
    gem)      __dotfiles_update_gems      ;;
    go)       __dotfiles_update_go        ;;
    heroku)   __dotfiles_update_heroku    ;;
    node)     __dotfiles_update_node      ;;
    nvm)      __dotfiles_update_nvm       ;;
  esac

  case "$OSTYPE" in
    linux*)   __dotfiles_update_linux   "$1" ;;
    darwin*)  __dotfiles_update_darwin  "$1" ;;
  esac
}

# vim: ft=sh :
